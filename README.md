# graph0
Win32 API app for graph drawing

![vSQK8iLlPi](https://user-images.githubusercontent.com/72271483/133840065-2fcb24c5-439e-428b-90e6-6a887ee4a486.gif)

## Об этом репозитории
Репозиторий содержит файлы Win32 API приложения, которое по заданной матрице смежности отрисовывает граф в окне.

## О том, как это работает
По нажатию на пункт меню File->Start drawing the graph **считывается матрица смежности** контроллером ввода-вывода IOController (файл IOcontroller.h). В случае ошибки ввода возникает соответствующее сообщение. Класс содержит всего один метод, но в перспективе будет развиваться вместе с расширением функционала приложения. На данный момент реализовано 3 класса для представления графа с позиции математики - базовый класс Math::Graph, его наследник Math::ConnectedGraph (односвязный граф) и Math::Tree - наследник ConnectedGraph'a (файл graph.h). **Матрица смежности**, преобразуясь в список смежности, **передается базовому классу**, который **укладывает граф** на плоскость относительных координат, создавая объект класса Paint::Graph (файл graph.h). Его задача управлять визуальным состоянием графа. Затем, объект класса Paint::Graph в терминах геометрических объектов (эллипс, линия, текст) **передает информацию о графе отрисовщику** - объекту класса Paint::Painter (файл painter.h). На этом этапе Painter все так же хранит относительные координаты объектов.

Теперь, каждый раз, когда необходимо **отрисовать граф** (по событию WM_PAINT) - при изменении размера окна, его перемещении и т.д. отрисовщику необходимо лишь **вывести свои объекты** на экран. Это делается с учетом размера окна. Координаты объектов, размеры кругов, определяющих вершины, толщина линий, задающих ребра, размер текста идентификаторов вершин, отступы от краев - **все это зависит от текущего размера окна, числа вершин и ребер.**

В качестве тестовых примеров имеется 3 файла: graph.txt, graph2.txt, graph3.txt. Пока что для выбора нужного файла нужно вручную прописывать его имя в файле graph0.cpp.

## Подробнее об укладке графа на плоскость
Первоначально, в качестве прототипа, укладка производилась так: все вершины графа равномерно расставлялись по окружности, затем нужные вершины соединялись ребрами. Простейший в реализации вариант, но визуально воспринимается с трудом. Сейчас используется следующий алгоритм.

Изначальный граф разбивается на односвязные графы, каждый из которых рисуется отдельно алгоритмом выше. Однако, если односвязный граф - дерево, то для него производится [радиальная укладка](https://en.wikipedia.org/wiki/Radial_tree). В дальнейшем для односвязных графов, не являющихся деревьями, планируется реализация [гамма-алгоритма](https://ru.wikipedia.org/wiki/%D0%93%D0%B0%D0%BC%D0%BC%D0%B0-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC). Далее все отдельно отрисованные компоненты собираются в один граф, при этом чем больше вершин в компоненте, тем больше площадь его участка в финальном графе. По сути, рассматривалась задача максимально плотного объединения набора прямоугольников в одну "максимально квадратную" фигуру.

## Дальнейшее развитие проекта
В будущем планируется добавить следующий функционал:

* Реализация гамма-алгоритма для укладки односвязных графов
* Менеджер выбора графов для отрисовки (сейчас для этого необходимо вручную прописывать название исходника с матрицей смежности)
* Редактор графов для создания их из приложения
